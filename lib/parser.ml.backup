(** Parser Module Implementation *)

open Ast
open Lexer

(** Result type for parsing outcomes *)
type parse_result =
  | PR_Success of json 
  | PR_Error of string 

(** Initialize parser state (wrapper around lexer) *)
let init_parser = init_lexer

(** Helper function to skip whitespace using lexer *)
let skip_whitespace state =
  let (_, new_state) = tokenize state in
  new_state

(** Parsing functions *)
let rec parse_value (state : lexer_state) : (json * lexer_state) =
  let (token, new_state) = tokenize state in
  match token with
  | T_String s -> (JString s, new_state)
  | T_Number n -> (JNumber n, new_state)
  | T_Bool b -> (JBool b, new_state)
  | T_Null -> (JNull, new_state)
  | T_LBrace -> parse_object new_state
  | T_LBracket -> parse_array new_state
  | T_EOF -> failwith "Unexpected EOF in parse_value"
  | _ -> failwith ("Unexpected token in parse_value")

and parse_object (state : lexer_state) : (json * lexer_state) =
  let rec parse_pairs state acc =
    let state = skip_whitespace state in
    let (next_token, _) = tokenize state in
    match next_token with
    | T_RBrace -> (List.rev acc, state)
    | T_EOF -> failwith "Unexpected EOF in object"
    | _ ->
        let (key, state1) = tokenize state in
        let (colon_token, state2) = tokenize (skip_whitespace state1) in
        (match colon_token with
        | T_Colon -> ()
        | _ -> failwith "Expected colon in object");
        let (value, state3) = parse_value (skip_whitespace state2) in
        let new_acc = (match key with T_String k -> (k, value) | _ -> failwith "Expected string key") :: acc in
        let state4 = skip_whitespace state3 in
        let (comma_token, state5) = tokenize state4 in
        (match comma_token with
        | T_Comma -> parse_pairs state5 new_acc
        | _ -> parse_pairs state4 new_acc)
  in
  let (pairs, final_state) = parse_pairs state [] in
  (JObject pairs, final_state)

and parse_array (state : lexer_state) : (json * lexer_state) =
  let rec parse_elements state acc =
    let state = skip_whitespace state in
    let (next_token, _) = tokenize state in
    match next_token with
    | T_RBracket -> (List.rev acc, state)
    | T_EOF -> failwith "Unexpected EOF in array"
    | _ ->
        let (value, state1) = parse_value state in
        let new_acc = value :: acc in
        let state2 = skip_whitespace state1 in
        let (comma_token, state3) = tokenize state2 in
        (match comma_token with
        | T_Comma -> parse_elements state3 new_acc
        | _ -> parse_elements state2 new_acc)
  in
  let (elements, final_state) = parse_elements state [] in
  (JArray elements, final_state)

(** Parse input string and return result *)
let parse (state : lexer_state) : parse_result =
  try
    let (ast, final_state) = parse_value state in
    let final_state = skip_whitespace final_state in
    let (token, _) = tokenize final_state in
    (match token with
    | T_EOF -> PR_Success ast
    | _ -> PR_Error "Extra input after parsing")
  with
  | Failure msg -> PR_Error ("Parse error: " ^ msg)
  | exn -> PR_Error ("Unexpected error: " ^ Printexc.to_string exn)